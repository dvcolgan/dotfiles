#!/usr/bin/env python
"""
A simple file browser server implemented using FastAPI.

This script creates a web server that allows browsing the filesystem starting from
the user's home directory. It maps file paths relative to the home folder to URLs.
When navigating to a URL:
- If it points to a file, the file content is rendered or downloaded
- If it points to a directory, its contents are listed as clickable links
- If it points to an image file, the image is displayed in the browser
- If it points to a text file (txt, md, card, html, json, yaml), the content is displayed

The server handles path traversal protection and proper MIME type detection for files.
The design uses a single unified template that can display both directories and
individual items. When viewing a directory, files (including images and text files) 
are previewed inline within the page using the same template as when viewing them individually.
"""

import os
import mimetypes
from pathlib import Path
from typing import Annotated, List, Optional

from fastapi import FastAPI, HTTPException, Request, Query, Form
from fastapi.responses import HTMLResponse, StreamingResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
import uvicorn

app = FastAPI(title="File Browser")

# Create a templates directory for the HTML templates
templates_dir = Path.home() / "templates"
templates_dir.mkdir(exist_ok=True)

# Create a unified template file
template_file = templates_dir / "unified.html"
if not template_file.exists():
    with open(template_file, "w") as f:
        f.write("""
<!DOCTYPE html>
<html>
<head>
    <title>File Browser - {{ current_path }}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        h1 { margin-bottom: 20px; }
        .breadcrumb { margin-bottom: 20px; padding: 10px; background-color: #f8f9fa; }
        .item { display: flex; padding: 5px; border-bottom: 1px solid #eee; align-items: flex-start; }
        .item:hover { background-color: #f8f9fa; }
        .item-name { flex-grow: 1; }
        .item-size { width: 100px; text-align: right; color: #6c757d; }
        .item-date { width: 200px; text-align: right; color: #6c757d; }
        .folder { color: #007bff; }
        .file { color: #212529; }
        .parent { margin-bottom: 10px; }
        .image-container { 
            margin: 20px auto;
            padding: 10px;
            border: 1px solid #ddd;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: inline-block;
        }
        .single-view { text-align: center; }
        img.preview { max-width: 100px; max-height: 100px; margin-right: 10px; }
        img.full { max-width: 100%; max-height: 80vh; }
        .image-info { margin-top: 10px; color: #6c757d; }
        .back-button { margin-top: 20px; }
        .back-button a { 
            padding: 10px 20px; 
            background-color: #007bff; 
            color: white; 
            text-decoration: none;
            border-radius: 4px;
        }
        .back-button a:hover { background-color: #0056b3; }
        .preview-container { width: 100px; text-align: center; margin-right: 10px; flex-shrink: 0; }
        .text-preview-container {
            width: 300px;
            height: 100px;
            text-align: left;
            margin-right: 10px;
            overflow: hidden;
            border: 1px solid #ddd;
            padding: 5px;
            font-family: monospace;
            font-size: 10px;
            background-color: #f8f9fa;
            flex-shrink: 0;
        }
        .text-preview {
            width: 100%;
            height: 100%;
            overflow: hidden;
            white-space: pre-wrap;
        }
        .file-content {
            margin: 20px auto;
            padding: 15px;
            border: 1px solid #ddd;
            background-color: #f8f9fa;
            overflow: auto;
            max-width: 90%;
            max-height: 80vh;
            white-space: pre-wrap;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>File Browser</h1>
    <div class="breadcrumb">
        <a href="/">Home</a> / 
        {% for part in breadcrumbs %}
            <a href="{{ part.path }}">{{ part.name }}</a> / 
        {% endfor %}
    </div>
    
    {% if is_directory %}
        {% if current_path != "/" %}
        <div class="parent">
            <a href="{{ parent_path }}">..</a> (Parent Directory)
        </div>
        {% endif %}
        
        {% for item in items %}
        <div class="item">
            {% if item.is_image %}
            <div class="preview-container">
                <a href="{{ item.path }}"><img src="/raw{{ item.path }}" class="preview" alt="{{ item.name }}"></a>
            </div>
            {% elif item.is_text %}
            <div class="text-preview-container">
                <a href="{{ item.path }}"><div class="text-preview">{{ item.preview }}</div></a>
            </div>
            {% endif %}
            <div class="item-name">
                <a href="{{ item.path }}" class="{{ 'folder' if item.is_dir else 'file' }}">
                    {{ item.name }}{{ '/' if item.is_dir else '' }}
                </a>
            </div>
            <div class="item-size">{{ item.size }}</div>
            <div class="item-date">{{ item.modified }}</div>
        </div>
        {% endfor %}
    {% else %}
        <div class="single-view">
            {% if is_image %}
                <div class="image-container">
                    <img src="/raw{{ current_path }}" class="full" alt="{{ file_name }}">
                    <div class="image-info">
                        <p>{{ file_name }} ({{ file_size }})</p>
                    </div>
                </div>
            {% elif is_text %}
                <div class="file-content">{{ file_content }}</div>
            {% else %}
                <p>This file type cannot be previewed. <a href="/raw{{ current_path }}" download>Download</a></p>
            {% endif %}
            
            <div class="back-button">
                <a href="{{ parent_path }}">Back to Directory</a>
            </div>
        </div>
    {% endif %}
</body>
</html>
        """)

templates = Jinja2Templates(directory=str(templates_dir))

# Get the user's home directory
HOME_DIR = Path.home()

# List of image file extensions
IMAGE_EXTENSIONS = [
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', 
    '.tiff', '.tif', '.svg', '.ico', '.heic', '.heif'
]

# List of text file extensions that should be displayed with preview
TEXT_FILE_EXTENSIONS = [
    '.txt', '.md', '.markdown', '.card', '.html', '.htm', 
    '.json', '.yaml', '.yml', '.py', '.js', '.css', '.xml',
    '.csv', '.log', '.sh', '.bat', '.rst', '.conf', '.ini'
]

# List of text file MIME types
TEXT_MIME_TYPES = [
    "text/", "application/json", "application/xml", 
    "application/javascript", "application/x-javascript"
]


def is_safe_path(path: Path) -> bool:
    """Check if the path is safe and doesn't try to access files outside HOME_DIR."""
    try:
        # Resolve to absolute path and check if it's within HOME_DIR
        resolved_path = path.resolve()
        return resolved_path == HOME_DIR or HOME_DIR in resolved_path.parents
    except (ValueError, RuntimeError):
        return False


def format_size(size_bytes: int) -> str:
    """Format file size in human-readable format."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024 or unit == 'TB':
            return f"{size_bytes:.2f} {unit}" if unit != 'B' else f"{size_bytes} {unit}"
        size_bytes /= 1024


def is_image_file(file_path: Path) -> bool:
    """Check if the file is an image based on its extension."""
    return file_path.suffix.lower() in IMAGE_EXTENSIONS


def is_text_file(file_path: Path) -> bool:
    """Check if the file is a text file based on its extension or MIME type."""
    # First check by extension
    if file_path.suffix.lower() in TEXT_FILE_EXTENSIONS:
        return True
    
    # Then check by MIME type
    content_type, _ = mimetypes.guess_type(str(file_path))
    if not content_type:
        return False
    return any(content_type.startswith(mime) for mime in TEXT_MIME_TYPES)


def get_file_content(file_path: Path, preview_mode: bool = False) -> str:
    """
    Get the content of a text file as a string.
    
    Args:
        file_path: Path to the text file
        preview_mode: If True, only return a snippet of the content for preview
    
    Returns:
        String content of the file, possibly truncated if in preview mode
    """
    try:
        with open(file_path, 'r', errors='replace') as f:
            if preview_mode:
                # Read first 500 characters for preview
                return f.read(500)
            return f.read()
    except Exception:
        return "Error: Could not read file content"


def get_breadcrumbs(path: str):
    """Calculate breadcrumbs for navigation."""
    breadcrumbs = []
    current_path = ""
    parts = path.split("/") if path else []
    
    for part in parts:
        if not part:
            continue
        current_path = f"{current_path}/{part}"
        breadcrumbs.append({"name": part, "path": current_path})
    
    return breadcrumbs


def get_parent_path(path: str) -> str:
    """Determine parent directory URL."""
    if not path or path == "/":
        return "/"
    
    parent_parts = path.split("/")
    if len(parent_parts) <= 1:
        return "/"
    else:
        return "/" + "/".join(parent_parts[:-1])


@app.get("/raw/{path:path}")
async def get_raw_file(path: str = ""):
    """
    Serve raw file content, used for displaying images and downloading files.
    
    Args:
        path: The relative path from the home directory
        
    Returns:
        The raw file content with appropriate content type
    """
    if path.startswith("/"):
        path = path[1:]
    
    fs_path = HOME_DIR / path
    
    # Security check to prevent directory traversal
    if not is_safe_path(fs_path):
        raise HTTPException(status_code=403, detail="Access forbidden")
    
    # Check if the path exists
    if not fs_path.exists() or not fs_path.is_file():
        raise HTTPException(status_code=404, detail="File not found")
    
    # Get MIME type
    content_type, encoding = mimetypes.guess_type(str(fs_path))
    content_type = content_type or "application/octet-stream"
    
    # Stream the file content
    def file_generator():
        with open(fs_path, 'rb') as file:
            yield from file
    
    return StreamingResponse(
        file_generator(),
        media_type=content_type
    )


@app.get("/{path:path}", response_class=HTMLResponse)
async def browse_path(request: Request, path: str = ""):
    """
    Serve files and directories from the user's home directory.
    
    Args:
        request: The FastAPI request object
        path: The relative path from the home directory
    
    Returns:
        - HTML directory listing for directories with inline previews
        - HTML page with file content for files
        - 404 if the path doesn't exist
        - 403 if the path is outside the home directory
    """
    # Normalize the requested path
    if path.startswith("/"):
        path = path[1:]
    
    # Construct the actual filesystem path
    fs_path = HOME_DIR / path
    
    # Security check to prevent directory traversal
    if not is_safe_path(fs_path):
        raise HTTPException(status_code=403, detail="Access forbidden")
    
    # Check if the path exists
    if not fs_path.exists():
        raise HTTPException(status_code=404, detail="Path not found")
    
    # Calculate breadcrumbs and parent directory for any type of path
    breadcrumbs = get_breadcrumbs(path)
    parent_path = get_parent_path(path)
    
    # If it's a directory, list its contents
    if fs_path.is_dir():
        # Get directory contents
        items = []
        for item in fs_path.iterdir():
            # Skip hidden files/folders
            if item.name.startswith('.'):
                continue
                
            rel_path = item.relative_to(HOME_DIR)
            url_path = f"/{rel_path}"
            
            # Get file/directory metadata
            modified_time = item.stat().st_mtime
            modified = f"{modified_time:.0f}"  # Simple timestamp format
            
            is_image = False
            is_text = False
            preview = None
            
            if item.is_file():
                if is_image_file(item):
                    is_image = True
                elif is_text_file(item):
                    is_text = True
                    # Generate a preview for text files
                    preview = get_file_content(item, preview_mode=True)
            
            if item.is_dir():
                items.append({
                    "name": item.name,
                    "path": url_path,
                    "is_dir": True,
                    "is_image": False,
                    "is_text": False,
                    "preview": None,
                    "size": "-",
                    "modified": modified
                })
            else:
                items.append({
                    "name": item.name,
                    "path": url_path,
                    "is_dir": False,
                    "is_image": is_image,
                    "is_text": is_text,
                    "preview": preview,
                    "size": format_size(item.stat().st_size),
                    "modified": modified
                })
        
        # Sort items: directories first, then files, each sorted alphabetically
        items.sort(key=lambda x: (not x["is_dir"], x["name"].lower()))
        
        # Render directory template
        return templates.TemplateResponse(
            "unified.html",
            {
                "request": request,
                "items": items,
                "is_directory": True,
                "current_path": f"/{path}" if path else "/",
                "breadcrumbs": breadcrumbs,
                "parent_path": parent_path
            }
        )
    
    # If it's a file, serve it
    elif fs_path.is_file():
        is_image = is_image_file(fs_path)
        is_text = is_text_file(fs_path) and not is_image
        file_content = get_file_content(fs_path) if is_text else None
        
        # Render file template
        return templates.TemplateResponse(
            "unified.html",
            {
                "request": request,
                "is_directory": False,
                "is_image": is_image,
                "is_text": is_text,
                "file_name": fs_path.name,
                "file_size": format_size(fs_path.stat().st_size),
                "file_content": file_content,
                "current_path": f"/{path}" if path else "/",
                "breadcrumbs": breadcrumbs,
                "parent_path": parent_path
            }
        )


if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=4444)

# I've modified the code to support previewing text files in the directory view similar to how images are previewed.
# 
# Key changes:
# 1. Added a list of text file extensions to identify file types that should be previewed
# 2. Enhanced the is_text_file() function to first check by extension and then fall back to MIME type
# 3. Modified get_file_content() to support a preview mode that only returns a snippet of text
# 4. Added a text-preview-container div in the HTML template to style the text previews
# 5. Updated the directory listing logic to generate text previews for supported file types
# 6. For each text file in a directory, we now show a small preview of its contents directly in the directory listing
# 
# The previews maintain consistency with the image preview system, showing a snippet of each text file
# in a directory view and the full content when viewing the file directly.

"""
This works great, but I want to be able to see the text files inline when looking at a folder. I can see images inline currently when looking at a folder.

I can see the contents of the text type files if I go to them directly, but if I view a folder, currently I just see the filename again. I want to see the content inline there as well.

Basically I want to see the full contents of all files inline, if I'm looking at a folder, and just the file's contents if I am looking at a single file.

Make this change please
"""
